"""
This type stub file was generated by pyright.
"""

import sys
import types
import StringIO

"""Utilities for writing code that runs on Python 2 and 3"""
__author__ = ...
__version__ = ...
PY2 = ...
PY3 = ...
PY34 = ...
if PY3:
    string_types = ...
    integer_types = ...
    class_types = ...
    text_type = ...
    binary_type = ...
    MAXSIZE = ...
else:
    string_types = ...
    integer_types = ...
    class_types = ...
    text_type = ...
    binary_type = ...
class _LazyDescr:
    def __init__(self, name) -> None:
        ...
    
    def __get__(self, obj, tp):
        ...
    


class MovedModule(_LazyDescr):
    def __init__(self, name, old, new=...) -> None:
        ...
    
    def __getattr__(self, attr): # -> Any:
        ...
    


class _LazyModule(types.ModuleType):
    def __init__(self, name) -> None:
        ...
    
    def __dir__(self): # -> list[str]:
        ...
    
    _moved_attributes = ...


class MovedAttribute(_LazyDescr):
    def __init__(self, name, old_mod, new_mod, old_attr=..., new_attr=...) -> None:
        ...
    


class _SixMetaPathImporter:
    """
    A meta path importer to import six.moves and its submodules.

    This class implements a PEP302 finder and loader. It should be compatible
    with Python 2.5 and all existing versions of Python3
    """
    def __init__(self, six_module_name) -> None:
        ...
    
    def find_module(self, fullname, path=...): # -> Self@_SixMetaPathImporter | None:
        ...
    
    def load_module(self, fullname): # -> ModuleType:
        ...
    
    def is_package(self, fullname): # -> bool:
        """
        Return true, if the named module is a package.

        We need this method to get correct spec objects with
        Python 3.4 (see PEP451)
        """
        ...
    
    def get_code(self, fullname): # -> None:
        """Return None

        Required, if is_package is implemented"""
        ...
    
    get_source = ...


_importer = ...
class _MovedItems(_LazyModule):
    """Lazy loading of moved objects"""
    __path__ = ...


_moved_attributes = ...
if sys.platform == "win32":
    ...
moves = ...
class Module_six_moves_urllib_parse(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_parse"""
    ...


_urllib_parse_moved_attributes = ...
class Module_six_moves_urllib_error(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_error"""
    ...


_urllib_error_moved_attributes = ...
class Module_six_moves_urllib_request(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_request"""
    ...


_urllib_request_moved_attributes = ...
class Module_six_moves_urllib_response(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_response"""
    ...


_urllib_response_moved_attributes = ...
class Module_six_moves_urllib_robotparser(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_robotparser"""
    ...


_urllib_robotparser_moved_attributes = ...
class Module_six_moves_urllib(types.ModuleType):
    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    __path__ = ...
    parse = ...
    error = ...
    request = ...
    response = ...
    robotparser = ...
    def __dir__(self): # -> list[str]:
        ...
    


def add_move(move): # -> None:
    """Add an item to six.moves."""
    ...

def remove_move(name): # -> None:
    """Remove item from six.moves."""
    ...

if PY3:
    _meth_func = ...
    _meth_self = ...
    _func_closure = ...
    _func_code = ...
    _func_defaults = ...
    _func_globals = ...
else:
    _meth_func = ...
    _meth_self = ...
    _func_closure = ...
    _func_code = ...
    _func_defaults = ...
    _func_globals = ...
next = ...
if PY3:
    def get_unbound_function(unbound):
        ...
    
    create_bound_method = ...
    def create_unbound_method(func, cls):
        ...
    
    Iterator = ...
else:
    def get_unbound_function(unbound):
        ...
    
    def create_bound_method(func, obj): # -> MethodType:
        ...
    
    def create_unbound_method(func, cls): # -> MethodType:
        ...
    
    class Iterator:
        def next(self):
            ...
        
    
    
    callable = ...
get_method_function = ...
get_method_self = ...
get_function_closure = ...
get_function_code = ...
get_function_defaults = ...
get_function_globals = ...
if PY3:
    def iterkeys(d, **kw): # -> Iterator[Unknown]:
        ...
    
    def itervalues(d, **kw): # -> Iterator[Unknown]:
        ...
    
    def iteritems(d, **kw): # -> Iterator[Unknown]:
        ...
    
    def iterlists(d, **kw): # -> Iterator[Unknown]:
        ...
    
    viewkeys = ...
    viewvalues = ...
    viewitems = ...
else:
    def iterkeys(d, **kw):
        ...
    
    def itervalues(d, **kw):
        ...
    
    def iteritems(d, **kw):
        ...
    
    def iterlists(d, **kw):
        ...
    
    viewkeys = ...
    viewvalues = ...
    viewitems = ...
if PY3:
    def b(s):
        ...
    
    def u(s):
        ...
    
    unichr = ...
    int2byte = ...
    byte2int = ...
    indexbytes = ...
    iterbytes = ...
    StringIO = ...
    BytesIO = ...
    _assertCountEqual = ...
else:
    def b(s):
        ...
    
    def u(s):
        ...
    
    unichr = ...
    int2byte = ...
    def byte2int(bs): # -> int:
        ...
    
    def indexbytes(buf, i): # -> int:
        ...
    
    iterbytes = ...
    StringIO = ...
    _assertCountEqual = ...
    _assertRaisesRegex = ...
    _assertRegex = ...
def assertCountEqual(self, *args, **kwargs): # -> Any:
    ...

def assertRaisesRegex(self, *args, **kwargs): # -> Any:
    ...

def assertRegex(self, *args, **kwargs): # -> Any:
    ...

if PY3:
    exec_ = ...
    def reraise(tp, value, tb=...): # -> NoReturn:
        ...
    
else:
    def exec_(_code_, _globs_=..., _locs_=...): # -> None:
        """Execute code in a namespace."""
        ...
    
if sys.version_info[: 2] == (3, 2):
    ...
else:
    def raise_from(value, from_value): # -> NoReturn:
        ...
    
print_ = ...
if print_ is None:
    def print_(*args, **kwargs):
        """The new-style print function for Python 2.4 and 2.5."""
        ...
    
if sys.version_info[: 2] < (3, 3):
    _print = ...
    def print_(*args, **kwargs): # -> None:
        ...
    
if sys.version_info[0: 2] < (3, 4):
    def wraps(wrapped, assigned=..., updated=...): # -> (f: Unknown) -> Unknown:
        ...
    
else:
    wraps = ...
def with_metaclass(meta, *bases): # -> metaclass:
    """Create a base class with a metaclass."""
    class metaclass(meta):
        ...
    
    

def add_metaclass(metaclass): # -> (cls: Unknown) -> Unknown:
    """Class decorator for creating a class with a metaclass."""
    ...

def python_2_unicode_compatible(klass):
    """
    A decorator that defines __unicode__ and __str__ methods under Python 2.
    Under Python 3 it does nothing.

    To support Python 2 and 3 with a single code base, define a __str__ method
    returning text and apply this decorator to the class.
    """
    ...

__path__ = ...
__package__ = ...
if globals().get("__spec__") is not None:
    ...
if sys.meta_path:
    ...
